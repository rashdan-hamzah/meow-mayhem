<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Meow Mayhem üòº</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#0e0f13; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; }
  #ui { position:fixed; inset:0; pointer-events:none; }
  .topbar { display:flex; gap:16px; align-items:center; padding:10px 12px; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,.5); }
  .pill { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); backdrop-filter: blur(4px); }
  .score { display:flex; gap:8px; align-items:center; }
  .pchip { padding:4px 8px; border-radius:999px; font-size:14px; font-weight:800; }
  .p1 { background:#ff9aa2; color:#2a1a1d; }
  .p2 { background:#9ad1ff; color:#121a24; }
  .p3 { background:#b5ff9a; color:#0f1a10; }
  .p4 { background:#ffdf9a; color:#1a160f; }
  .p5 { background:#c4a2ff; color:#1a1024; }
  .ctr { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center; }
  .btn { display:inline-block; padding:12px 18px; border-radius:12px; background:#2c2f3a; color:#fff; font-weight:800; letter-spacing:.3px; cursor:pointer; box-shadow:0 6px 20px rgba(0,0,0,.35); }
  .btn:active { transform:translate(-50%,-48%); }
  .hint { opacity:.8; margin-top:8px; font-size:14px; }
  canvas { display:block; width:100vw; height:100vh; }
  .bottom { position:fixed; bottom:10px; left:50%; transform:translateX(-50%); font-size:13px; opacity:.8; }
  .powerups { position:fixed; top:50px; right:10px; display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
  .powerup { display:flex; gap:4px; align-items:center; padding:4px 8px; border-radius:8px; background:rgba(255,255,255,.1); font-size:13px; }
  .powerup-icon { font-size:20px; }
  .timer { position:fixed; top:10px; right:10px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); backdrop-filter:blur(4px); font-weight:700; }
  
  /* Night mode animation */
  @keyframes nightPulse {
    0% { background-color: rgba(0,0,40,.3); }
    50% { background-color: rgba(0,0,60,.4); }
    100% { background-color: rgba(0,0,40,.3); }
  }
  .night-mode { position:fixed; inset:0; pointer-events:none; background-color: rgba(0,0,40,.3); z-index:10; animation: nightPulse 5s infinite; }
  
  /* Secret sauce animation */
  @keyframes secretSauceWarning {
    0% { background-color: rgba(255,0,0,.0); }
    50% { background-color: rgba(255,0,0,.15); }
    100% { background-color: rgba(255,0,0,.0); }
  }
  .warning { animation: secretSauceWarning 1s infinite; position:fixed; inset:0; pointer-events:none; z-index:11; }
  
  /* Eating animation */
  @keyframes eatingPulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.7; }
    100% { transform: scale(0.1); opacity: 0; }
  }
  .eating { animation: eatingPulse 1s forwards; }
  
  /* Player cat images */
  .cat-img {
    position: absolute;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 50%;
    transition: box-shadow 0.2s ease;
  }
  
  /* Multiplayer Lobby Styles */
  .screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #0e0f13;
    z-index: 100;
    overflow: auto;
  }

  /* Lobby Screen */
  .lobby-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 40px 20px;
    text-align: center;
  }

  .lobby-container h1 {
    font-size: 48px;
    margin-bottom: 40px;
  }

  .join-create {
    display: flex;
    gap: 40px;
    justify-content: center;
    align-items: stretch;
  }

  .create-game, .join-game {
    flex: 1;
    background: #1a1e2a;
    border-radius: 16px;
    padding: 24px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  }

  .divider {
    display: flex;
    align-items: center;
    color: #666;
    font-weight: bold;
  }

  .player-customization {
    margin: 20px 0;
    text-align: left;
  }

  .player-customization label {
    display: block;
    margin: 12px 0 6px;
    font-weight: 600;
  }

  .player-customization input {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    background: #2c2f3a;
    border: 1px solid #3a3f52;
    color: white;
    font-size: 16px;
  }

  .cat-selection {
    display: flex;
    gap: 12px;
    margin-top: 8px;
  }

  .cat-option {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: #2c2f3a;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .cat-option:hover {
    transform: scale(1.1);
    background: #3a3f52;
  }

  .cat-option.selected {
    background: #5a5f72;
    box-shadow: 0 0 0 3px #8f95b0;
  }

  .btn {
    display: inline-block;
    padding: 12px 24px;
    border-radius: 12px;
    background: #2c2f3a;
    color: #fff;
    font-weight: 800;
    letter-spacing: .3px;
    cursor: pointer;
    box-shadow: 0 6px 20px rgba(0,0,0,.35);
    border: none;
    font-size: 16px;
    margin-top: 20px;
    transition: all 0.2s;
  }

  .btn:hover {
    background: #3a3f52;
    transform: translateY(-2px);
  }

  .btn:active {
    transform: translateY(1px);
  }

  /* Waiting Room */
  .waiting-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 40px 20px;
    text-align: center;
  }

  .room-info {
    background: #1a1e2a;
    border-radius: 16px;
    padding: 24px;
    margin: 30px 0;
    box-shadow: 0 8px 24px rgba(0,0,0,0.2);
  }

  .room-info h2 {
    font-size: 32px;
    margin: 0 0 10px;
  }

  #roomCodeDisplay {
    font-size: 36px;
    background: #2c2f3a;
    padding: 8px 16px;
    border-radius: 12px;
    margin: 0 5px;
    letter-spacing: 2px;
  }

  .players-list {
    background: #1a1e2a;
    border-radius: 16px;
    padding: 20px;
    margin: 30px 0;
    text-align: left;
  }

  .players-list h3 {
    margin-top: 0;
    font-size: 20px;
    text-align: center;
  }

  #playersList {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #playersList li {
    padding: 12px 16px;
    border-radius: 8px;
    background: #2c2f3a;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
  }

  .player-cat {
    font-size: 24px;
    margin-right: 12px;
  }

  .player-name {
    flex-grow: 1;
    font-weight: bold;
  }

  .player-you {
    font-size: 12px;
    color: #9ad1ff;
    margin-left: 8px;
  }

  .player-host {
    font-size: 18px;
    margin-left: 8px;
  }

  #hostControls {
    margin-top: 30px;
  }

  #startGameBtn {
    background: #ff9aa2;
    color: #2a1a1d;
    font-size: 18px;
    padding: 14px 36px;
  }

  #startGameBtn:hover {
    background: #ffb0b6;
  }

  #waitingMessage {
    color: #888;
    font-style: italic;
  }

  .remote-cat {
    opacity: 0.8; /* Make remote players slightly transparent */
  }

  /* Notification System */
  #notificationArea {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    pointer-events: none;
  }

  .notification {
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 30px;
    margin-bottom: 10px;
    backdrop-filter: blur(4px);
    animation: fadeInOut 3s forwards;
  }

  @keyframes fadeInOut {
    0% { opacity: 0; transform: translateY(-20px); }
    10% { opacity: 1; transform: translateY(0); }
    80% { opacity: 1; }
    100% { opacity: 0; transform: translateY(-20px); }
  }

  /* Debug overlay */
  #debugOverlay {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
    z-index: 1000;
    max-height: 200px;
    overflow-y: auto;
  }

  /* Mobile Responsive Adjustments */
  @media (max-width: 800px) {
    .join-create {
      flex-direction: column;
      gap: 20px;
    }
    
    .divider {
      padding: 10px 0;
    }
    
    .lobby-container h1 {
      font-size: 36px;
    }
  }
</style>
<!-- Socket.io client library -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
<!-- Lobby Screen -->
<div id="lobbyScreen" class="screen">
  <div class="lobby-container">
    <h1>Meow Mayhem üòº</h1>
    
    <div class="join-create">
      <div class="create-game">
        <h2>Create New Game</h2>
        <div class="player-customization">
          <label>Your Name:</label>
          <input type="text" id="hostPlayerName" maxlength="15" value="Host Cat">
          
          <label>Choose Cat:</label>
          <div class="cat-selection">
            <div class="cat-option selected" data-index="0">üòæ</div>
            <div class="cat-option" data-index="1">üåà</div>
            <div class="cat-option" data-index="2">üéπ</div>
            <div class="cat-option" data-index="3">ü•Å</div>
            <div class="cat-option" data-index="4">üëπ</div>
          </div>
        </div>
        <button id="createGameBtn" class="btn">Create Game</button>
      </div>
      
      <div class="divider">OR</div>
      
      <div class="join-game">
        <h2>Join Game</h2>
        <div class="player-customization">
          <label>Your Name:</label>
          <input type="text" id="guestPlayerName" maxlength="15" value="Guest Cat">
          
          <label>Choose Cat:</label>
          <div class="cat-selection">
            <div class="cat-option selected" data-index="0">üòæ</div>
            <div class="cat-option" data-index="1">üåà</div>
            <div class="cat-option" data-index="2">üéπ</div>
            <div class="cat-option" data-index="3">ü•Å</div>
            <div class="cat-option" data-index="4">üëπ</div>
          </div>
          
          <label>Room Code:</label>
          <input type="text" id="roomCodeInput" maxlength="6" placeholder="ABCD12">
        </div>
        <button id="joinGameBtn" class="btn">Join Game</button>
      </div>
    </div>
  </div>
</div>

<!-- Waiting Room Screen -->
<div id="waitingRoom" class="screen" style="display:none;">
  <div class="waiting-container">
    <h1>Waiting for Players</h1>
    
    <div class="room-info">
      <h2>Room Code: <span id="roomCodeDisplay">ABCD12</span></h2>
      <p>Share this code with friends to join!</p>
    </div>
    
    <div class="players-list">
      <h3>Players:</h3>
      <ul id="playersList">
        <!-- Players will be added here dynamically -->
      </ul>
    </div>
    
    <div id="hostControls" style="display:none;">
      <button id="startGameBtn" class="btn">Start Game</button>
    </div>
    
    <p id="waitingMessage">Waiting for host to start the game...</p>
  </div>
</div>

<canvas id="game"></canvas>
<div id="ui">
  <div class="topbar">
    <div class="pill">üòº <strong>Meow Mayhem</strong></div>
    <div id="scores" class="score"></div>
    <div class="pill" id="status"></div>
  </div>
  <div id="center" class="ctr">
    <div style="font-size:42px; font-weight:900; margin-bottom:10px;">Meow Mayhem üòº</div>
    <div style="font-size:18px; opacity:.9; margin-bottom:20px;">Collect üêü. Bonk friends. Avoid chaos. First to <span id="targetPts">30</span> wins.</div>
    <div class="btn" id="startBtn">Press ENTER or Click to Start</div>
    <div class="hint">P1: WASD + F ‚Ä¢ P2: Arrows + / ‚Ä¢ (Enable up to 5 players in code)</div>
  </div>
  <div id="powerups" class="powerups"></div>
  <div id="timer" class="timer">Chaos in: 30s</div>
  <div class="bottom">Pause: <b>P</b> ‚Ä¢ Restart: <b>R</b></div>
</div>
<div id="nightMode" class="night-mode" style="display:none;"></div>
<div id="warning" class="warning" style="display:none;"></div>

<!-- Cat images container (will be dynamically populated) -->
<div id="catImagesContainer" style="position:absolute; top:0; left:0; pointer-events:none;"></div>

<script>
(() => {
  // ======== CONFIG ========
  const CONFIG = {
    targetScore: 30,
    maxPlayers: 2, // FIXED: Strictly limit to 2 players for multiplayer
    playerRadius: 25,
    playerSpeed: 2.4,
    friction: 0.86,
    meowCooldownMs: 1100,
    meowKnockRange: 140,
    meowKnockForce: 9.5,
    meowParticles: 12,
    treatRadius: 10,
    treatsOnField: 6,
    treatRespawnMs: 1600,
    dogeEveryMs: 9000,
    dogeSpeed: 2.0,
    dogeEatTimeMs: 1000,
    roombas: 2,
    laserCount: 5,
    laserActive: true,
    laserInvertMs: 2000,
    boundsPadding: 8,
    powerUpChance: 0.004,
    weatherEvents: true,
    weatherDuration: 8000,
    weatherCooldown: 5000,
    secretSauceInterval: 30000,
    secretSauceDuration: 8000,
    debugMode: true, // Enable debug overlay
    interpolationFactor: 0.2, // Movement smoothing (0-1, higher = snappier)
  };

  // ======== SOCKET.IO MULTIPLAYER ========
  let socket;
  let roomCode = '';
  let playerId = '';
  let isHost = false;
  let remotePlayers = {};
  let currentScreen = 'lobby'; // 'lobby', 'waiting', 'game'
  let hostId = '';
  let lastReceivedPlayers = {}; // Keep track of the last state from the server
  let isMultiplayerGame = false; // Flag to check if we're in a multiplayer game
  let serverSyncEnabled = true; // Flag to enable/disable server synchronization
  let lastReceivedState = null; // Store the last received game state from server
  let lastStateTime = 0; // Timestamp of last received game state

  // Helper function to get consistent remote player IDs
  function getRemotePlayerId(socketId) {
    return 'remote-' + socketId;
  }

  // Initialize Socket.io and UI events
  function initializeMultiplayer() {
    console.log("Initializing multiplayer");
    socket = io('https://meow-mayhem-server.onrender.com');
    
    // Setup event listeners
    setupSocketEvents();
    setupUIEvents();
    
    // Show lobby screen
    showScreen('lobbyScreen');
    
    // Create notification area
    createNotificationArea();
    
    // Create debug overlay if needed
    if (CONFIG.debugMode) {
      createDebugOverlay();
    }
  }

  function setupSocketEvents() {
    // Connection events
    socket.on('connect', () => {
      console.log('Connected to game server!');
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    socket.on('disconnect', () => {
      console.log('Disconnected from server');
      // Show disconnect message or return to lobby
      if (currentScreen === 'game') {
        showNotification('Disconnected from server');
        setTimeout(() => {
          showScreen('lobbyScreen');
          currentScreen = 'lobby';
          isMultiplayerGame = false;
        }, 3000);
      }
    });
    
    // Room creation and joining
    socket.on('room-created', (data) => {
      console.log('Room created:', data);
      roomCode = data.roomCode;
      playerId = data.playerId;
      isHost = true;
      hostId = playerId;
      
      // Update UI
      document.getElementById('roomCodeDisplay').textContent = roomCode;
      document.getElementById('hostControls').style.display = 'block';
      document.getElementById('waitingMessage').style.display = 'none';
      
      // Update players list
      const playerName = localStorage.getItem('playerName') || 'Host Cat';
      const skinIndex = parseInt(localStorage.getItem('selectedSkinIndex') || '0');
      
      updatePlayersList([{
        id: playerId,
        name: playerName,
        skinIndex: skinIndex
      }]);
      
      // Show waiting room
      showScreen('waitingRoom');
      currentScreen = 'waiting';
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    socket.on('room-joined', (data) => {
      console.log('Room joined:', data);
      roomCode = data.roomCode;
      playerId = data.playerId;
      isHost = data.isHost;
      hostId = data.players ? Object.keys(data.players).find(id => data.players[id].isHost) : '';
      
      // Store the last received players state
      lastReceivedPlayers = data.players || {};
      
      // Update UI
      document.getElementById('roomCodeDisplay').textContent = roomCode;
      document.getElementById('hostControls').style.display = isHost ? 'block' : 'none';
      document.getElementById('waitingMessage').style.display = isHost ? 'none' : 'block';
      
      // Update players list with all existing players
      const playersList = Object.values(data.players || {});
      updatePlayersList(playersList);
      
      // Show waiting room
      showScreen('waitingRoom');
      currentScreen = 'waiting';
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    socket.on('join-error', (data) => {
      showNotification('Error: ' + data.message);
    });
    
    // Player events
    socket.on('player-joined', (data) => {
      console.log('Player joined:', data);
      
      // Add to last received players
      if (data.id) {
        lastReceivedPlayers[data.id] = data;
      }
      
      // Add player to list
      addPlayerToList(data);
      
      // Show notification
      showNotification(`${data.name} joined the game!`);
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    socket.on('player-left', (disconnectedPlayerId) => {
      console.log('Player left:', disconnectedPlayerId);
      
      // Remove from last received players
      if (disconnectedPlayerId && lastReceivedPlayers[disconnectedPlayerId]) {
        delete lastReceivedPlayers[disconnectedPlayerId];
      }
      
      // Remove player from waiting room list
      removePlayerFromList(disconnectedPlayerId);
      
      // CRITICAL FIX: Properly clean up remote player if in game
      if (currentScreen === 'game') {
        const remoteId = getRemotePlayerId(disconnectedPlayerId);
        
        if (remotePlayers[remoteId]) {
          console.log(`Removing remote player: ${remoteId}`);
          
          // Remove player's visual representation
          if (remotePlayers[remoteId].imgElement) {
            remotePlayers[remoteId].imgElement.remove();
          }
          
          // Remove score display
          const scoreEl = document.getElementById(`score-${remoteId}`);
          if (scoreEl && scoreEl.parentNode) {
            scoreEl.parentNode.removeChild(scoreEl);
          }
          
          // Remove from remote players object
          delete remotePlayers[remoteId];
          
          showNotification('A player left the game');
        }
      }
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    socket.on('new-host', (newHostId) => {
      console.log('New host:', newHostId);
      hostId = newHostId;
      isHost = (newHostId === playerId);
      
      if (currentScreen === 'waiting') {
        document.getElementById('hostControls').style.display = isHost ? 'block' : 'none';
        document.getElementById('waitingMessage').style.display = isHost ? 'none' : 'block';
      }
      
      if (isHost) {
        showNotification('You are now the host!');
      }
      
      // Update the host crown in the player list
      updateHostDisplay(newHostId);
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    // Game events
    socket.on('game-started', (gameState) => {
      console.log('Game started with state:', gameState);
      isMultiplayerGame = true;
      
      // CRITICAL FIX: Force hide all screens first
      document.querySelectorAll('.screen').forEach(screen => {
        screen.style.display = 'none';
      });
      
      // CRITICAL FIX: Force hide the center UI element (start screen)
      document.getElementById('center').style.display = 'none';
      
      // Show game canvas and UI
      document.getElementById('game').style.display = 'block';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('timer').style.display = 'block';
      
      // Initialize game with received state
      initializeGameWithState(gameState);
      
      currentScreen = 'game';
      showNotification('Game started!');
      
      // Update debug info
      if (CONFIG.debugMode) updateDebugInfo();
    });
    
    socket.on('player-updated', (data) => {
      // Skip updates about our own player to prevent duplication
      if (data.id === playerId) {
        return;
      }
      
      // Update remote player position and state
      updateRemotePlayer(data);
    });
    
    socket.on('player-action', (data) => {
      // Skip actions from our own player
      if (data.id === playerId) {
        return;
      }
      
      // Handle remote player actions
      handleRemotePlayerAction(data);
    });
    
    socket.on('treat-spawned', (treatData) => {
      // Add new treat to game
      spawnTreatFromData(treatData);
    });
    
    // NEW: Full game state synchronization events
    socket.on('game-state-update', (gameState) => {
      if (!isMultiplayerGame || !serverSyncEnabled) return;
      
      // Store the received state and time
      lastReceivedState = gameState;
      lastStateTime = performance.now();
      
      // Sync all game elements
      syncTreats(gameState.treats);
      syncDoge(gameState.doge);
      syncRoombas(gameState.roombas);
      syncLasers(gameState.lasers);
      syncWeather(gameState.weather);
      syncPowerUps(gameState.powerUps);
      syncSecretSauce(gameState.secretSauce);
      
      // Update debug info
      if (CONFIG.debugMode && Math.random() < 0.1) updateDebugInfo();
    });
    
    // NEW: Direct game interactions from server
    socket.on('laser-hit', (data) => {
      if (players.length > 0) {
        // Apply invert controls to local player
        players[0].invertUntil = performance.now() + 2000; // 2 seconds
        updateStatus(`${players[0].name} is distracted by the LASER!`);
        
        // Particle effect when hit by laser
        const laser = lasers.find(l => l.id === data.laserId);
        if (laser) {
          createMeowParticles(laser.x, laser.y, "#ff3333");
        }
      }
    });
    
    socket.on('roomba-hit', (data) => {
      if (players.length > 0) {
        // Apply force to local player
        players[0].vx += data.forceX;
        players[0].vy += data.forceY;
        
        // Small particles when hitting roomba
        const roomba = roombas.find(r => r.id === data.roombaId);
        if (roomba) {
          createMeowParticles(
            players[0].x - (data.forceX * players[0].r), 
            players[0].y - (data.forceY * players[0].r), 
            "#aaaaaa"
          );
        }
      }
    });
    
    socket.on('doge-eat', (data) => {
      if (players.length > 0) {
        // Mark player as being eaten
        players[0].beingEaten = true;
        players[0].eatenUntil = performance.now() + (data.eatenUntil - Date.now());
        
        // Set respawn point
        players[0].respawnPoint = {
          x: data.respawnX,
          y: data.respawnY
        };
        
        // Eating effect particles
        createExplosion(players[0].x, players[0].y, "#ff6600", 25);
        
        updateStatus(`${players[0].name} was eaten by Doge!`);
      }
    });
  }
  
  // ======== IMPROVED MULTIPLAYER SYNC ========
  
  // Synchronize treat positions with server
  function syncTreats(serverTreats) {
    if (!serverTreats) return;
    
    // Remove treats that aren't in the server list
    for (let i = treats.length - 1; i >= 0; i--) {
      const localTreat = treats[i];
      const serverTreat = serverTreats.find(t => t.id === localTreat.id);
      if (!serverTreat) {
        treats.splice(i, 1);
      }
    }
    
    // Update or add treats from server
    serverTreats.forEach(serverTreat => {
      const localTreat = treats.find(t => t.id === serverTreat.id);
      if (localTreat) {
        // Update existing treat with interpolation targets
        localTreat.targetX = serverTreat.x;
        localTreat.targetY = serverTreat.y;
        localTreat.vx = serverTreat.vx || 0;
        localTreat.vy = serverTreat.vy || 0;
        
        // If the difference is large, snap directly
        if (Math.abs(localTreat.x - serverTreat.x) > 50 || 
            Math.abs(localTreat.y - serverTreat.y) > 50) {
          localTreat.x = serverTreat.x;
          localTreat.y = serverTreat.y;
        }
      } else {
        // Add new treat
        const newTreat = { 
          id: serverTreat.id,
          x: serverTreat.x,
          y: serverTreat.y,
          targetX: serverTreat.x,
          targetY: serverTreat.y,
          r: CONFIG.treatRadius, 
          emoji:'üêü',
          vx: serverTreat.vx || 0,
          vy: serverTreat.vy || 0
        };
        treats.push(newTreat);
      }
    });
  }
  
  // Synchronize doge with server
  function syncDoge(serverDoge) {
    if (!serverDoge) {
      // Remove doge if it doesn't exist on server
      doge = null;
      return;
    }
    
    if (!doge) {
      // Create doge if it doesn't exist locally
      doge = {
        x: serverDoge.x,
        y: serverDoge.y,
        targetX: serverDoge.x,
        targetY: serverDoge.y,
        r: 26,
        vx: serverDoge.vx,
        vy: serverDoge.vy,
        emoji: 'üê∂',
        ttl: serverDoge.ttl || 15000,
        eating: null,
        eatingStartTime: 0
      };
    } else {
      // Update existing doge with interpolation targets
      doge.targetX = serverDoge.x;
      doge.targetY = serverDoge.y;
      doge.vx = serverDoge.vx;
      doge.vy = serverDoge.vy;
      doge.ttl = serverDoge.ttl;
      
      // If the difference is large, snap directly
      if (Math.abs(doge.x - serverDoge.x) > 50 || 
          Math.abs(doge.y - serverDoge.y) > 50) {
        doge.x = serverDoge.x;
        doge.y = serverDoge.y;
      }
      
      // Handle eating state
      if (serverDoge.eating) {
        const eatenPlayerId = serverDoge.eating;
        
        // If eating a remote player
        if (eatenPlayerId !== playerId) {
          const remoteId = getRemotePlayerId(eatenPlayerId);
          if (remotePlayers[remoteId]) {
            doge.eating = remotePlayers[remoteId];
          }
        } 
        // If eating local player
        else if (players.length > 0 && !players[0].beingEaten) {
          doge.eating = players[0];
          
          // Set local player to eaten state if not already
          players[0].beingEaten = true;
          players[0].eatenUntil = performance.now() + CONFIG.dogeEatTimeMs;
          players[0].respawnPoint = {
            x: serverDoge.respawnX || rnd(100, W-100),
            y: serverDoge.respawnY || rnd(100, H-100)
          };
          createExplosion(players[0].x, players[0].y, "#ff6600", 25);
        }
      } else {
        doge.eating = null;
      }
    }
  }
  
  // Synchronize roombas with server
  function syncRoombas(serverRoombas) {
    if (!serverRoombas) return;
    
    // Remove roombas that aren't in the server list
    for (let i = roombas.length - 1; i >= 0; i--) {
      const localRoomba = roombas[i];
      const serverRoomba = serverRoombas.find(r => r.id === localRoomba.id);
      if (!serverRoomba) {
        roombas.splice(i, 1);
      }
    }
    
    // Update or add roombas from server
    serverRoombas.forEach(serverRoomba => {
      const localRoomba = roombas.find(r => r.id === serverRoomba.id);
      if (localRoomba) {
        // Update with interpolation targets
        localRoomba.targetX = serverRoomba.x;
        localRoomba.targetY = serverRoomba.y;
        localRoomba.vx = serverRoomba.vx;
        localRoomba.vy = serverRoomba.vy;
        
        // If the difference is large, snap directly
        if (Math.abs(localRoomba.x - serverRoomba.x) > 50 || 
            Math.abs(localRoomba.y - serverRoomba.y) > 50) {
          localRoomba.x = serverRoomba.x;
          localRoomba.y = serverRoomba.y;
        }
      } else {
        // Add new roomba
        roombas.push({
          id: serverRoomba.id,
          x: serverRoomba.x,
          y: serverRoomba.y,
          targetX: serverRoomba.x,
          targetY: serverRoomba.y,
          r: 18,
          vx: serverRoomba.vx,
          vy: serverRoomba.vy,
          emoji:'üßπ',
        });
      }
    });
  }
  
  // Synchronize lasers with server
  function syncLasers(serverLasers) {
    if (!serverLasers) return;
    
    // Remove lasers that aren't in the server list
    for (let i = lasers.length - 1; i >= 0; i--) {
      const localLaser = lasers[i];
      const serverLaser = serverLasers.find(l => l.id === localLaser.id);
      if (!serverLaser) {
        lasers.splice(i, 1);
      }
    }
    
    // Update or add lasers from server
    serverLasers.forEach(serverLaser => {
      const localLaser = lasers.find(l => l.id === serverLaser.id);
      if (localLaser) {
        // Update with interpolation targets
        localLaser.targetX = serverLaser.x;
        localLaser.targetY = serverLaser.y;
        localLaser.t = serverLaser.t || 0;
        localLaser.laserTargetX = serverLaser.targetX;
        localLaser.laserTargetY = serverLaser.targetY;
        localLaser.speed = serverLaser.speed || 3.5;
        
        // If the difference is large, snap directly
        if (Math.abs(localLaser.x - serverLaser.x) > 50 || 
            Math.abs(localLaser.y - serverLaser.y) > 50) {
          localLaser.x = serverLaser.x;
          localLaser.y = serverLaser.y;
        }
      } else {
        // Add new laser
        lasers.push({
          id: serverLaser.id,
          x: serverLaser.x,
          y: serverLaser.y,
          targetX: serverLaser.x,
          targetY: serverLaser.y,
          r: 10,
          emoji: 'üî¥',
          t: serverLaser.t || 0,
          laserTargetX: serverLaser.targetX,
          laserTargetY: serverLaser.targetY,
          speed: serverLaser.speed || 3.5
        });
      }
    });
  }
  
  // Synchronize weather with server
  function syncWeather(serverWeather) {
    if (!serverWeather) {
      // End current weather if server has none
      if (currentWeather) {
        currentWeather.event.onEnd();
        currentWeather = null;
      }
      return;
    }
    
    // Check if it's a new weather event
    if (!currentWeather || currentWeather.event.name !== serverWeather.name) {
      // End current weather if exists
      if (currentWeather) {
        currentWeather.event.onEnd();
      }
      
      // Start new weather
      const weatherEvent = WEATHER_EVENTS.find(e => e.name === serverWeather.name);
      if (weatherEvent) {
        currentWeather = {
          event: weatherEvent,
          endTime: performance.now() + (serverWeather.duration || CONFIG.weatherDuration)
        };
        weatherEvent.onStart();
      }
    }
  }
  
  // Synchronize power-ups with server
  function syncPowerUps(serverPowerUps) {
    if (!serverPowerUps) return;
    
    // Remove power-ups that aren't in the server list
    for (let i = powerUps.length - 1; i >= 0; i--) {
      const localPowerUp = powerUps[i];
      const serverPowerUp = serverPowerUps.find(p => p.id === localPowerUp.id);
      if (!serverPowerUp) {
        powerUps.splice(i, 1);
      }
    }
    
    // Add/update power-ups from server
    serverPowerUps.forEach(serverPowerUp => {
      const localPowerUp = powerUps.find(p => p.id === serverPowerUp.id);
      if (!localPowerUp) {
        const powerUpType = POWERUPS.find(t => t.name === serverPowerUp.type) || POWERUPS[0];
        powerUps.push({
          id: serverPowerUp.id,
          x: serverPowerUp.x,
          y: serverPowerUp.y,
          targetX: serverPowerUp.x,
          targetY: serverPowerUp.y,
          r: 15,
          type: powerUpType,
          emoji: powerUpType.emoji,
          collectTime: 0,
          collectPlayer: null,
          pulsePhase: 0
        });
      } else {
        // Update existing power-up with interpolation targets
        localPowerUp.targetX = serverPowerUp.x;
        localPowerUp.targetY = serverPowerUp.y;
        
        // If the difference is large, snap directly
        if (Math.abs(localPowerUp.x - serverPowerUp.x) > 50 || 
            Math.abs(localPowerUp.y - serverPowerUp.y) > 50) {
          localPowerUp.x = serverPowerUp.x;
          localPowerUp.y = serverPowerUp.y;
        }
      }
    });
  }
  
  // Synchronize secret sauce state with server
  function syncSecretSauce(serverSecretSauce) {
    if (!serverSecretSauce) return;
    
    // Update secret sauce state
    secretSauceActive = serverSecretSauce.active;
    
    if (secretSauceActive) {
      document.getElementById('warning').style.display = 'block';
      document.getElementById('timer').textContent = 'CHAOS MODE!';
      updateStatus('‚ö†Ô∏è CHAOS MODE ACTIVATED! ‚ö†Ô∏è');
    } else {
      document.getElementById('warning').style.display = 'none';
      document.getElementById('timer').textContent = `Chaos in: ${serverSecretSauce.countdown || 30}s`;
      updateStatus('');
    }
    
    // Update countdown
    secretSauceCountdown = serverSecretSauce.countdown || 30;
  }
  
  // Perform interpolation updates
  function updateInterpolation() {
    const factor = CONFIG.interpolationFactor;
    
    // Interpolate treat positions
    for (const t of treats) {
      if (t.targetX !== undefined && t.targetY !== undefined) {
        t.x += (t.targetX - t.x) * factor;
        t.y += (t.targetY - t.y) * factor;
      }
    }
    
    // Interpolate roomba positions
    for (const r of roombas) {
      if (r.targetX !== undefined && r.targetY !== undefined) {
        r.x += (r.targetX - r.x) * factor;
        r.y += (r.targetY - r.y) * factor;
      }
    }
    
    // Interpolate laser positions
    for (const l of lasers) {
      if (l.targetX !== undefined && l.targetY !== undefined) {
        l.x += (l.targetX - l.x) * factor;
        l.y += (l.targetY - l.y) * factor;
      }
    }
    
    // Interpolate doge position
    if (doge && doge.targetX !== undefined && doge.targetY !== undefined && !doge.eating) {
      doge.x += (doge.targetX - doge.x) * factor;
      doge.y += (doge.targetY - doge.y) * factor;
    }
    
    // Interpolate power-up positions
    for (const p of powerUps) {
      if (p.targetX !== undefined && p.targetY !== undefined) {
        p.x += (p.targetX - p.x) * factor;
        p.y += (p.targetY - p.y) * factor;
      }
    }
  }
  
  // Request treat from server instead of spawning locally
  function requestTreatFromServer() {
    if (socket && socket.connected && isMultiplayerGame) {
      socket.emit('request-treat');
    }
  }

  function setupUIEvents() {
    // Create game button
    document.getElementById('createGameBtn').addEventListener('click', () => {
      const playerName = document.getElementById('hostPlayerName').value.trim();
      if (!playerName) {
        showNotification('Please enter your name');
        return;
      }
      
      const skinIndex = parseInt(document.querySelector('#lobbyScreen .create-game .cat-selection .selected').dataset.index);
      
      // CRITICAL FIX: Store selected skin and name for later use
      localStorage.setItem('selectedSkinIndex', skinIndex);
      localStorage.setItem('playerName', playerName);
      
      socket.emit('create-room', {
        playerName: playerName,
        skinIndex: skinIndex
      });
    });
    
    // Join game button
    document.getElementById('joinGameBtn').addEventListener('click', () => {
      const playerName = document.getElementById('guestPlayerName').value.trim();
      const roomCodeValue = document.getElementById('roomCodeInput').value.trim().toUpperCase();
      
      if (!playerName) {
        showNotification('Please enter your name');
        return;
      }
      
      if (!roomCodeValue || roomCodeValue.length !== 6) {
        showNotification('Please enter a valid room code');
        return;
      }
      
      const skinIndex = parseInt(document.querySelector('#lobbyScreen .join-game .cat-selection .selected').dataset.index);
      
      // CRITICAL FIX: Store selected skin and name for later use
      localStorage.setItem('selectedSkinIndex', skinIndex);
      localStorage.setItem('playerName', playerName);
      
      socket.emit('join-room', {
        roomCode: roomCodeValue,
        playerName: playerName,
        skinIndex: skinIndex
      });
    });
    
    // Start game button
    document.getElementById('startGameBtn').addEventListener('click', () => {
      if (isHost) {
        socket.emit('start-game');
      }
    });
    
    // Cat selection
    document.querySelectorAll('.cat-option').forEach(option => {
      option.addEventListener('click', (e) => {
        // Remove selected class from siblings
        e.target.parentElement.querySelectorAll('.cat-option').forEach(opt => {
          opt.classList.remove('selected');
        });
        
        // Add selected class to clicked option
        e.target.classList.add('selected');
      });
    });
  }

  // Helper UI functions - FIXED VERSION
  function showScreen(screenId) {
    console.log(`Showing screen: ${screenId}`);
    
    // Hide all screens first
    document.querySelectorAll('.screen').forEach(screen => {
      screen.style.display = 'none';
    });
    
    // CRITICAL FIX: Extra handling for game screen
    if (screenId === 'game') {
      // Hide start screen overlay
      document.getElementById('center').style.display = 'none';
      
      // Show game elements
      document.getElementById('game').style.display = 'block';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('timer').style.display = 'block';
      
      currentScreen = 'game';
    } else {
      // Hide game elements when in lobby/waiting room
      document.getElementById('game').style.display = 'none';
      document.getElementById('ui').style.display = 'none';
      document.getElementById('timer').style.display = 'none';
      document.getElementById('center').style.display = 'none';
      
      // Show the requested screen
      document.getElementById(screenId).style.display = 'block';
      currentScreen = screenId;
    }
    
    // Update debug info
    if (CONFIG.debugMode) updateDebugInfo();
  }

  function updatePlayersList(players) {
    const list = document.getElementById('playersList');
    list.innerHTML = '';
    
    players.forEach(player => {
      addPlayerToList(player);
    });
  }

  function addPlayerToList(player) {
    const list = document.getElementById('playersList');
    const item = document.createElement('li');
    item.dataset.playerId = player.id;
    
    // Get cat emoji based on skin index
    const catEmojis = ['üòæ', 'üåà', 'üéπ', 'ü•Å', 'üëπ'];
    const catEmoji = catEmojis[player.skinIndex] || catEmojis[0];
    
    item.innerHTML = `
      <span class="player-cat">${catEmoji}</span>
      <span class="player-name">${player.name}</span>
      ${player.id === playerId ? ' <span class="player-you">(You)</span>' : ''}
      ${player.id === hostId ? ' <span class="player-host">üëë</span>' : ''}
    `;
    
    list.appendChild(item);
  }

  function removePlayerFromList(playerId) {
    const item = document.querySelector(`#playersList li[data-player-id="${playerId}"]`);
    if (item) item.remove();
  }

  function updateHostDisplay(newHostId) {
    // Remove all host crowns
    document.querySelectorAll('.player-host').forEach(el => el.remove());
    
    // Add crown to new host
    const hostItem = document.querySelector(`#playersList li[data-player-id="${newHostId}"]`);
    if (hostItem) {
      const hostSpan = document.createElement('span');
      hostSpan.className = 'player-host';
      hostSpan.textContent = ' üëë';
      hostItem.appendChild(hostSpan);
    }
  }

  function createNotificationArea() {
    // Remove existing notification area if it exists
    const existingArea = document.getElementById('notificationArea');
    if (existingArea) existingArea.remove();
    
    const notificationArea = document.createElement('div');
    notificationArea.id = 'notificationArea';
    document.body.appendChild(notificationArea);
  }

  function showNotification(message) {
    const notificationArea = document.getElementById('notificationArea');
    
    if (!notificationArea) return;
    
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.textContent = message;
    
    notificationArea.appendChild(notification);
    
    // Remove after animation completes
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 3000);
  }
  
  // Add debug overlay to help track player entities
  function createDebugOverlay() {
    if (document.getElementById('debugOverlay')) {
      return document.getElementById('debugOverlay');
    }
    
    const overlay = document.createElement('div');
    overlay.id = 'debugOverlay';
    document.body.appendChild(overlay);
    
    return overlay;
  }

  // Update debug info
  function updateDebugInfo() {
    if (!CONFIG.debugMode) return;
    
    const overlay = createDebugOverlay();
    if (!overlay) return;
    
    let info = `Local Player ID: ${playerId}<br>`;
    info += `Host ID: ${hostId}<br>`;
    info += `Room Code: ${roomCode}<br>`;
    info += `Screen: ${currentScreen}<br>`;
    info += `Multiplayer: ${isMultiplayerGame ? 'Yes' : 'No'}<br>`;
    info += `Last State: ${lastStateTime ? Math.round(performance.now() - lastStateTime) + 'ms ago' : 'None'}<br>`;
    info += `Local Players: ${players.length}<br>`;
    info += `Remote Players: ${Object.keys(remotePlayers).length}<br>`;
    
    // List all remote players
    if (Object.keys(remotePlayers).length > 0) {
      info += '<br>Remote Players:<br>';
      for (const id in remotePlayers) {
        info += `- ${id}: ${remotePlayers[id].x.toFixed(0)},${remotePlayers[id].y.toFixed(0)}<br>`;
      }
    }
    
    // Add game elements counts
    info += `<br>Game Elements:<br>`;
    info += `Treats: ${treats.length}<br>`;
    info += `Roombas: ${roombas.length}<br>`;
    info += `Lasers: ${lasers.length}<br>`;
    info += `PowerUps: ${powerUps.length}<br>`;
    info += `Doge: ${doge ? 'Present' : 'None'}<br>`;
    info += `Weather: ${currentWeather ? currentWeather.event.name : 'None'}<br>`;
    
    overlay.innerHTML = info;
  }

  // Game integration functions - FIXED VERSION
  function initializeGameWithState(gameState) {
    console.log('Initializing game with state', gameState);
    
    // Reset game state completely
    resetGame();
    
    // CRITICAL FIX: Start with exactly one local player
    // First clean up any existing player images
    while (catImagesContainer.firstChild) {
      catImagesContainer.removeChild(catImagesContainer.firstChild);
    }
    
    // Clear all players
    players.length = 0;
    
    // Clear all remote players to prevent duplicates
    for (const id in remotePlayers) {
      if (remotePlayers[id].imgElement) {
        remotePlayers[id].imgElement.remove();
      }
      
      // Also remove score elements
      const scoreEl = document.getElementById(`score-${id}`);
      if (scoreEl && scoreEl.parentNode) {
        scoreEl.parentNode.removeChild(scoreEl);
      }
    }
    remotePlayers = {};
    
    // Create ONE local player (player 0)
    console.log("Creating local player with ID 0");
    const playerSkinIndex = parseInt(localStorage.getItem('selectedSkinIndex') || '0');
    const playerName = localStorage.getItem('playerName') || 'Player';
    const skin = SKINS[playerSkinIndex % SKINS.length];
    const p = {
      id: 0, // Local player always has ID 0
      name: playerName,
      emoji: skin.emoji,
      color: skin.color,
      chip: skin.chip,
      skin: skin,
      x: W * 0.2,
      y: H * 0.3,
      vx: 0, vy: 0,
      r: CONFIG.playerRadius,
      score: 0,
      controls: CONTROL_SETS[0],
      invertUntil: 0,
      lastMeow: -9999,
      alive: true,
      isBeingMeowed: false,
      meowEffectUntil: 0,
      speedBoost: 1.0,
      hasShield: false,
      superMeow: false,
      treatMagnet: false,
      activePowerUps: [],
      beingEaten: false,
      eatenUntil: 0,
      respawnPoint: { x: 0, y: 0 }
    };
    
    // Create cat image element
    p.imgElement = createCatImage(p);
    players.push(p);
    
    // Use server state for all game elements
    if (gameState) {
      // Initialize treats
      treats.length = 0;
      if (gameState.treats) {
        gameState.treats.forEach(treatData => {
          spawnTreatFromData(treatData);
        });
      }
      
      // Initialize roombas
      roombas.length = 0;
      if (gameState.roombas) {
        gameState.roombas.forEach(roombaData => {
          spawnRoombaFromData(roombaData);
        });
      }
      
      // Initialize lasers
      if (gameState.lasers) {
        syncLasers(gameState.lasers);
      } else if (CONFIG.laserActive) {
        spawnLasers();
      }
      
      // Initialize doge
      if (gameState.doge) {
        syncDoge(gameState.doge);
      } else {
        doge = null;
      }
      
      // Initialize weather
      if (gameState.weather) {
        syncWeather(gameState.weather);
      } else {
        currentWeather = null;
      }
      
      // Initialize power-ups
      if (gameState.powerUps) {
        syncPowerUps(gameState.powerUps);
      }
      
      // Initialize secret sauce
      if (gameState.secretSauce) {
        syncSecretSauce(gameState.secretSauce);
      }
    } else {
      // Fallback to local initialization if no server state
      if (CONFIG.laserActive) spawnLasers();
      spawnRoombas();
      for(let i=0;i<CONFIG.treatsOnField;i++) spawnTreat();
    }
    
    // CRITICAL FIX: Force hide the center screen
    document.getElementById('center').style.display = 'none';
    
    // Update the UI
    updateScoreUI();
    
    // Start game loop
    running = true;
    last = performance.now();
    requestAnimationFrame(loop);
    
    // Create other players as remote players
    if (gameState && gameState.players) {
      // Create remote players for everyone except ourselves
      for (const id in gameState.players) {
        if (id === playerId) continue; // Skip our own player
        
        const playerData = gameState.players[id];
        updateRemotePlayer({
          id: id,
          position: playerData.position || { x: W/2, y: H/2 },
          skinIndex: playerData.skinIndex || 0,
          score: playerData.score || 0,
          name: playerData.name || 'Remote Player'
        });
      }
    }
    
    // Enable multiplayer sync
    isMultiplayerGame = true;
    serverSyncEnabled = true;
    lastStateTime = performance.now();
    
    // Update debug info
    if (CONFIG.debugMode) updateDebugInfo();
  }

  function spawnTreatFromData(treatData) {
    const t = { 
      id: treatData.id || Math.random().toString(36).substring(2, 15),
      x: treatData.x,
      y: treatData.y,
      targetX: treatData.x,
      targetY: treatData.y,
      r: CONFIG.treatRadius, 
      emoji:'üêü',
      vx: treatData.vx || 0,
      vy: treatData.vy || 0
    };
    treats.push(t);
  }

  function spawnRoombaFromData(roombaData) {
    const r = {
      id: roombaData.id || Math.random().toString(36).substring(2, 15),
      x: roombaData.x,
      y: roombaData.y,
      targetX: roombaData.x,
      targetY: roombaData.y,
      r: 18,
      vx: roombaData.vx,
      vy: roombaData.vy,
      emoji:'üßπ'
    };
    roombas.push(r);
  }

  // Update remote player - FIXED VERSION
  function updateRemotePlayer(data) {
    if (!data.id) return;
    
    // CRITICAL FIX: Use consistent ID format to avoid duplicates
    const id = getRemotePlayerId(data.id);
    
    // Check if this is a player we should be tracking
    if (data.id === playerId) {
      console.log('Ignoring update for our own player');
      return; // Don't create a remote version of our own player
    }
    
    // Create remote player if doesn't exist
    if (!remotePlayers[id]) {
      console.log(`Creating new remote player: ${id}`);
      remotePlayers[id] = {
        id: id,
        socketId: data.id, // Store original socket ID
        x: data.position ? data.position.x : W/2,
        y: data.position ? data.position.y : H/2,
        targetX: data.position ? data.position.x : W/2,
        targetY: data.position ? data.position.y : H/2,
        vx: data.position ? data.position.vx : 0,
        vy: data.position ? data.position.vy : 0,
        score: data.score || 0,
        r: CONFIG.playerRadius,
        skinIndex: data.skinIndex || 0,
        name: data.name || 'Remote Player',
        isRemote: true
      };
      
      // Create visual representation
      createRemotePlayerVisual(remotePlayers[id]);
    } else {
      // Update existing player
      if (data.position) {
        remotePlayers[id].targetX = data.position.x;
        remotePlayers[id].targetY = data.position.y;
        remotePlayers[id].vx = data.position.vx || remotePlayers[id].vx;
        remotePlayers[id].vy = data.position.vy || remotePlayers[id].vy;
      }
      
      if (data.score !== undefined) {
        remotePlayers[id].score = data.score;
        updateRemotePlayerScore(id, data.score);
      }
    }
  }

  function createRemotePlayerVisual(player) {
    // Create cat image for remote player
    const img = document.createElement('img');
    img.className = 'cat-img remote-cat';
    img.src = CAT_GIFS[player.skinIndex || 0];
    img.id = `remote-cat-${player.id}`;
    img.style.width = `${player.r * 2}px`;
    img.style.height = `${player.r * 2}px`;
    catImagesContainer.appendChild(img);
    
    player.imgElement = img;
    
    // Also add to score display
    const scoresEl = document.getElementById('scores');
    const span = document.createElement('span');
    span.className = `pchip p${(player.skinIndex % 5) + 1}`;
    span.id = `score-${player.id}`;
    
    // Use data from lastReceivedPlayers if available
    let playerName = player.name || "Remote";
    if (player.socketId && lastReceivedPlayers[player.socketId]) {
      playerName = lastReceivedPlayers[player.socketId].name || playerName;
    }
    
    span.textContent = `${SKINS[player.skinIndex].emoji} ${playerName}: ${player.score}`;
    scoresEl.appendChild(span);
    
    // Update debug info
    if (CONFIG.debugMode) updateDebugInfo();
  }

  function updateRemotePlayerScore(id, score) {
    const scoreEl = document.getElementById(`score-${id}`);
    if (scoreEl && remotePlayers[id]) {
      const skinIndex = remotePlayers[id].skinIndex || 0;
      
      // Use data from lastReceivedPlayers if available
      let playerName = remotePlayers[id].name || "Remote";
      if (remotePlayers[id].socketId && lastReceivedPlayers[remotePlayers[id].socketId]) {
        playerName = lastReceivedPlayers[remotePlayers[id].socketId].name || playerName;
      }
      
      scoreEl.textContent = `${SKINS[skinIndex].emoji} ${playerName}: ${score}`;
    }
  }

  // Update remote player positions with interpolation
  function updateRemotePlayerPositions() {
    for (const id in remotePlayers) {
      const player = remotePlayers[id];
      if (player.targetX !== undefined && player.targetY !== undefined) {
        // Interpolate position
        player.x += (player.targetX - player.x) * CONFIG.interpolationFactor;
        player.y += (player.targetY - player.y) * CONFIG.interpolationFactor;
        
        // Update visual
        if (player.imgElement) {
          player.imgElement.style.left = `${player.x}px`;
          player.imgElement.style.top = `${player.y}px`;
        }
      }
    }
  }

  function handleRemotePlayerAction(data) {
    if (!data.id || !data.action) return;
    
    // Skip actions from our own player
    if (data.id === playerId) return;
    
    const remoteId = getRemotePlayerId(data.id);
    
    switch (data.action) {
      case 'meow':
        createRemoteMeowEffect(data, remoteId);
        break;
        
      case 'collect-treat':
        // Handle remote player collecting treats
        for (let i = 0; i < treats.length; i++) {
          if (treats[i].id === data.treatId) {
            treats.splice(i, 1);
            
            // Visual effect for remote collection
            if (remotePlayers[remoteId]) {
              createMeowParticles(
                remotePlayers[remoteId].x,
                remotePlayers[remoteId].y,
                "#5dffea"
              );
              
              // Update remote player score
              if (data.score !== undefined) {
                remotePlayers[remoteId].score = data.score;
                updateRemotePlayerScore(remoteId, data.score);
              }
            }
            break;
          }
        }
        break;
        
      case 'game-end':
        // Handle game over from server
        if (data.winner) {
          showNotification(`üéâ ${data.winner} wins!`);
          paused = true;
          winner = {name: data.winner, emoji: 'üèÜ'};
        }
        break;
    }
  }

  function createRemoteMeowEffect(data, remoteId) {
    const player = remotePlayers[remoteId];
    if (!player) return;
    
    const now = performance.now();
    const position = data.position || { x: player.x, y: player.y };
    const superMeow = data.superMeow || false;
    
    // Create meow burst
    meowBursts.push({ 
      x: position.x, 
      y: position.y, 
      r: 10, 
      maxR: superMeow ? CONFIG.meowKnockRange * 1.5 : CONFIG.meowKnockRange, 
      born: now, 
      life: superMeow ? 420 : 320, 
      owner: player, 
      superMeow: superMeow 
    });
    
    // Create particles
    createMeowParticles(
      position.x,
      position.y,
      player.color || '#ffffff',
      superMeow ? CONFIG.meowParticles * 2 : CONFIG.meowParticles
    );
    
    // Apply effect to local player if in range
    if (players.length > 0) {
      const localPlayer = players[0]; // Player 0 is the local player
      const dx = localPlayer.x - position.x;
      const dy = localPlayer.y - position.y;
      const d = Math.hypot(dx, dy);
      const range = superMeow ? CONFIG.meowKnockRange * 1.5 : CONFIG.meowKnockRange;
      
      if (d > 0 && d <= range && !localPlayer.hasShield) {
        const nx = dx/d, ny = dy/d;
        const force = superMeow ? CONFIG.meowKnockForce * 1.5 : CONFIG.meowKnockForce;
        const adjustedForce = force * (1 - d/range + 0.2);
        
        localPlayer.vx += nx * adjustedForce;
        localPlayer.vy += ny * adjustedForce;
        
        // Mark player as being meowed
        localPlayer.isBeingMeowed = true;
        localPlayer.meowEffectUntil = now + 800;
      }
    }
  }

  // Cat GIFs for the players
  const CAT_GIFS = [
    "https://media.tenor.com/SuVGs-GL7RoAAAAi/shocked-shocked-cat.gif", // Grumpy
    "https://media.tenor.com/Ym6VeAcZoTcAAAAi/aaaah-cat.gif",          // Nyan
    "https://media.tenor.com/1Z8PTLFT8HUAAAAi/voices-cat.gif",         // Keyboard
    "https://media.tenor.com/T_avUEk3aWwAAAAi/catgroove7tv-catgroove.gif", // Bongo
    "https://media.tenor.com/y-Ew-QGLcpYAAAAi/shrek-cat.gif",          // Shrek Cat
  ];

  const SKINS = [
    { name:"Grumpy", emoji:"üòæ", chip:"p1", color:"#ff9aa2", gifIndex: 0 },
    { name:"Nyan", emoji:"üåà", chip:"p2", color:"#9ad1ff", gifIndex: 1 }, 
    { name:"Keyboard", emoji:"üéπ", chip:"p3", color:"#b5ff9a", gifIndex: 2 },
    { name:"Bongo", emoji:"ü•Å", chip:"p4", color:"#ffdf9a", gifIndex: 3 },
    { name:"Shrek", emoji:"üëπ", chip:"p5", color:"#c4a2ff", gifIndex: 4 },
  ];
  
  // Power-up types
  const POWERUPS = [
    { name: "Speed Boost", emoji: "‚ö°", color: "#ffff00", duration: 5000, effect: (player) => {
      player.speedBoost = 1.6;
      return () => player.speedBoost = 1.0;
    }},
    { name: "Shield", emoji: "üõ°Ô∏è", color: "#00ffff", duration: 6000, effect: (player) => {
      player.hasShield = true;
      return () => player.hasShield = false;
    }},
    { name: "Giant Mode", emoji: "ü¶ñ", color: "#ff00ff", duration: 7000, effect: (player) => {
      player.r *= 1.6;
      updateCatImageSize(player);
      return () => {
        player.r = CONFIG.playerRadius;
        updateCatImageSize(player);
      };
    }},
    { name: "Super Meow", emoji: "üîä", color: "#ff6600", duration: 8000, effect: (player) => {
      player.superMeow = true;
      return () => player.superMeow = false;
    }},
    { name: "Treat Magnet", emoji: "üß≤", color: "#cc33ff", duration: 10000, effect: (player) => {
      player.treatMagnet = true;
      return () => player.treatMagnet = false;
    }},
  ];
  
  // Weather events
  const WEATHER_EVENTS = [
    { name: "Night Mode", onStart: () => {
        document.getElementById("nightMode").style.display = "block";
        updateStatus("üåô Night Mode - Watch out for invisible obstacles!");
      }, onEnd: () => {
        document.getElementById("nightMode").style.display = "none";
        updateStatus("");
      }
    },
    { name: "Slippery Floor", onStart: () => {
        CONFIG.friction = 0.96;
        updateStatus("üßä Slippery Floor - Hard to control!");
      }, onEnd: () => {
        CONFIG.friction = 0.86;
        updateStatus("");
      }
    },
    { name: "Tornado", onStart: () => {
        spawnTornado();
        updateStatus("üå™Ô∏è Tornado Alert - Run for cover!");
      }, onEnd: () => {
        tornado = null;
        updateStatus("");
      }
    },
    { name: "Super Speed", onStart: () => {
        CONFIG.playerSpeed *= 1.5;
        updateStatus("üí® Everyone moves super fast!");
      }, onEnd: () => {
        CONFIG.playerSpeed /= 1.5;
        updateStatus("");
      }
    }
  ];

  // ======== SETUP ========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const catImagesContainer = document.getElementById('catImagesContainer');
  let W = 0, H = 0;
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    catImagesContainer.style.width = W + 'px';
    catImagesContainer.style.height = H + 'px';
  }
  resize();
  window.addEventListener('resize', resize);

  // ======== INPUT ========
  const keys = new Set();
  window.addEventListener('keydown', (e) => { 
    keys.add(e.key); 
    if (e.key === 'Enter') start(); 
    if ([' '].includes(e.key)) e.preventDefault(); 
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // ======== UTIL ========
  const rnd = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function circleCollide(ax,ay,ar, bx,by,br){ return Math.hypot(ax-bx, ay-by) <= ar+br; }
  function edgeBounce(entity, r){
    if (entity.x < r) { entity.x = r; entity.vx = Math.abs(entity.vx)*0.6; }
    if (entity.x > W - r) { entity.x = W - r; entity.vx = -Math.abs(entity.vx)*0.6; }
    if (entity.y < r) { entity.y = r; entity.vy = Math.abs(entity.vy)*0.6; }
    if (entity.y > H - r) { entity.y = H - r; entity.vy = -Math.abs(entity.vy)*0.6; }
  }

  // ======== ENTITIES ========
  const players = [];
  const treats = [];
  const roombas = [];
  const meowBursts = [];
  const meowParticles = [];
  const powerUps = [];
  let doge = null;
  const lasers = [];
  let tornado = null;
  let currentWeather = null;
  let nextWeatherEvent = 0;
  let nextSecretSauce = 0;
  let secretSauceActive = false;
  let secretSauceCountdown = 30;

  // Player controls map
  const CONTROL_SETS = [
    { up:'w', down:'s', left:'a', right:'d', meow:'f' },
    { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', meow:'/' },
    { up:'i', down:'k', left:'j', right:'l', meow:'h' },
    { up:'t', down:'g', left:'f', right:'h', meow:'y' },
    { up:'8', down:'5', left:'4', right:'6', meow:'0' },
  ];

  // Create cat image element for a player
  function createCatImage(player) {
    const img = document.createElement('img');
    img.className = 'cat-img';
    img.src = CAT_GIFS[player.skin.gifIndex];
    img.id = `cat-${player.id}`;
    img.style.width = `${player.r * 2}px`;
    img.style.height = `${player.r * 2}px`;
    catImagesContainer.appendChild(img);
    return img;
  }
  
  // Update cat image size (for power-ups, etc.)
  function updateCatImageSize(player) {
    if (player.imgElement) {
      player.imgElement.style.width = `${player.r * 2}px`;
      player.imgElement.style.height = `${player.r * 2}px`;
    }
  }
  
  // Update cat image position with improved error handling
  function updateCatImagePositions() {
    try {
      // Update local players
      players.forEach(p => {
        if (p && p.imgElement) {
          p.imgElement.style.left = `${p.x}px`;
          p.imgElement.style.top = `${p.y}px`;
          
          // Apply eating animation class if being eaten
          if (p.beingEaten) {
            p.imgElement.classList.add('eating');
          } else {
            p.imgElement.classList.remove('eating');
          }
          
          // Apply shield visual effect
          if (p.hasShield) {
            p.imgElement.style.boxShadow = '0 0 10px 5px rgba(0, 255, 255, 0.7)';
          } else if (p.isBeingMeowed) {
            p.imgElement.style.boxShadow = '0 0 8px 4px rgba(255, 255, 255, 0.6)';
          } else {
            p.imgElement.style.boxShadow = 'none';
          }
        }
      });
    } catch (error) {
      console.error('Error updating cat positions:', error);
    }
  }

  // CRITICAL FIX: Only spawn exactly one player in multiplayer mode
  function spawnPlayers(n=CONFIG.maxPlayers){
    // First clean up any existing player images
    while (catImagesContainer.firstChild) {
      catImagesContainer.removeChild(catImagesContainer.firstChild);
    }
    
    players.length = 0;
    
    // CRITICAL FIX: In multiplayer mode, only create one player (the local player)
    if (isMultiplayerGame) {
      // Create just one local player in multiplayer mode
      n = 1;
    }
    
    for(let i=0;i<n;i++){
      const skin = SKINS[i % SKINS.length];
      const p = {
        id:i,
        name: skin.name,
        emoji: skin.emoji,
        color: skin.color,
        chip: skin.chip,
        skin: skin,
        x: W*(0.2 + 0.2*i),
        y: H*(0.3 + 0.1*i),
        vx:0, vy:0,
        r: CONFIG.playerRadius,
        score:0,
        controls: CONTROL_SETS[i],
        invertUntil:0,
        lastMeow: -9999,
        alive:true,
        isBeingMeowed: false,
        meowEffectUntil: 0,
        speedBoost: 1.0,
        hasShield: false,
        superMeow: false,
        treatMagnet: false,
        activePowerUps: [],
        beingEaten: false,
        eatenUntil: 0,
        respawnPoint: { x: 0, y: 0 }
      };
      
      // Create cat image element
      p.imgElement = createCatImage(p);
      
      players.push(p);
    }
    updateScoreUI();
  }

  function spawnTreat(){
    // In multiplayer mode, request from server instead
    if (isMultiplayerGame && socket && socket.connected) {
      requestTreatFromServer();
      return;
    }
    
    const t = { 
      id: Math.random().toString(36).substring(2, 15),
      x: rnd(CONFIG.boundsPadding, W-CONFIG.boundsPadding),
      y: rnd(CONFIG.boundsPadding+40, H-CONFIG.boundsPadding),
      r: CONFIG.treatRadius, 
      emoji:'üêü',
      vx: 0,
      vy: 0
    };
    treats.push(t);
  }

  function ensureTreats(){
    // Skip in multiplayer mode - server will handle this
    if (isMultiplayerGame) return;
    
    while (treats.length < CONFIG.treatsOnField) spawnTreat();
  }

  function spawnRoombas(){
    // Skip in multiplayer mode - server will handle this
    if (isMultiplayerGame) return;
    
    roombas.length = 0;
    for (let i=0;i<CONFIG.roombas;i++){
      roombas.push({
        id: Math.random().toString(36).substring(2, 15),
        x: rnd(60, W-60),
        y: rnd(80, H-60),
        r: 18,
        vx: rnd(-1.4,1.4),
        vy: rnd(-1.4,1.4),
        emoji:'üßπ',
      });
    }
  }

  function spawnDoge(){
    // Skip in multiplayer mode - server will handle this
    if (isMultiplayerGame) return;
    
    const side = Math.random() < 0.5 ? 'L' : 'R';
    doge = {
      x: side==='L' ? -60 : W+60,
      y: rnd(90, H-90),
      r: 26,
      vx: side==='L' ? rnd(2.0,2.5) : rnd(-2.5,-2.0),
      vy: 0,
      emoji:'üê∂',
      ttl: 15000,
      target: null,
      eating: null,
      eatingStartTime: 0
    };
  }

  function spawnLasers(){
    // Skip in multiplayer mode - server will handle this
    if (isMultiplayerGame) return;
    
    lasers.length = 0;
    for (let i = 0; i < CONFIG.laserCount; i++) {
      lasers.push({
        id: Math.random().toString(36).substring(2, 15),
        x: rnd(40, W-40),
        y: rnd(90, H-40),
        r: 10,
        emoji: 'üî¥',
        t: Math.floor(rnd(0, 120)),
        targetX: rnd(40, W-40),
        targetY: rnd(90, H-40),
        speed: rnd(2.8, 4.2)
      });
    }
  }
  
  function spawnTornado() {
    // Skip in multiplayer mode - server will handle this
    if (isMultiplayerGame) return;
    
    tornado = {
      x: rnd(W * 0.25, W * 0.75),
      y: rnd(H * 0.25, H * 0.75),
      r: 50,
      vx: rnd(-2, 2),
      vy: rnd(-2, 2),
      pullForce: 0.4,
      rotationSpeed: 0.1,
      angle: 0,
      particles: []
    };
    
    // Create tornado particles
    for (let i = 0; i < 30; i++) {
      tornado.particles.push({
        x: tornado.x + rnd(-tornado.r, tornado.r),
        y: tornado.y + rnd(-tornado.r, tornado.r),
        size: rnd(4, 10),
        angle: rnd(0, Math.PI * 2),
        distance: rnd(5, tornado.r),
        speed: rnd(0.05, 0.15)
      });
    }
  }
  
  function spawnPowerUp() {
    // Skip in multiplayer mode - server will handle this
    if (isMultiplayerGame) return;
    
    const type = POWERUPS[Math.floor(Math.random() * POWERUPS.length)];
    const powerUp = {
      id: Math.random().toString(36).substring(2, 15),
      x: rnd(CONFIG.boundsPadding * 2, W - CONFIG.boundsPadding * 2),
      y: rnd(CONFIG.boundsPadding * 2 + 40, H - CONFIG.boundsPadding * 2),
      r: 15,
      type: type,
      emoji: type.emoji,
      collectTime: 0,
      collectPlayer: null,
      pulsePhase: 0
    };
    powerUps.push(powerUp);
  }

  // Create particle effect
  function createMeowParticles(x, y, color, count = CONFIG.meowParticles) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = rnd(2, 6);
      meowParticles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: rnd(3, 8),
        color: color,
        life: rnd(30, 80),
        opacity: 1
      });
    }
  }
  
  // Create explosion particles
  function createExplosion(x, y, color, count = 30) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = rnd(3, 8);
      meowParticles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: rnd(4, 10),
        color: color,
        life: rnd(40, 100),
        opacity: 1
      });
    }
  }
  
  // Respawn a player after being eaten
  function respawnPlayer(player) {
    player.beingEaten = false;
    player.x = player.respawnPoint.x;
    player.y = player.respawnPoint.y;
    player.vx = 0;
    player.vy = 0;
    player.alive = true;
    
    // Remove eating animation from image
    if (player.imgElement) {
      player.imgElement.classList.remove('eating');
    }
    
    // Create respawn particle effect
    createExplosion(player.x, player.y, player.color, 20);
  }

  // ======== GAME LOOP ========
  let running = false;
  let last = performance.now();
  let acc = 0;
  const dt = 1000/60;
  let nextTreatAt = 0;
  let nextDogeAt = 0;

  // FIXED version to handle game state
  function start(){
    if (running) return;
    
    // If we're in the lobby or waiting room, don't start local game
    if (currentScreen === 'lobby' || currentScreen === 'waiting') return;
    
    document.getElementById('center').style.display = 'none';
    document.getElementById('timer').style.display = 'block';
    running = true;
    resetGame();
    last = performance.now();
    requestAnimationFrame(loop);
  }

  function resetGame(){
    // FIXED version - ensure only maxPlayers players
    spawnPlayers(CONFIG.maxPlayers);
    treats.length=0;
    roombas.length=0;
    meowBursts.length=0;
    meowParticles.length=0;
    powerUps.length=0;
    doge = null;
    tornado = null;
    currentWeather = null;
    if (CONFIG.laserActive) spawnLasers();
    spawnRoombas();
    for(let i=0;i<CONFIG.treatsOnField;i++) spawnTreat();
    nextTreatAt = performance.now() + CONFIG.treatRespawnMs;
    nextDogeAt = performance.now() + CONFIG.dogeEveryMs;
    nextWeatherEvent = performance.now() + 5000;
    nextSecretSauce = performance.now() + CONFIG.secretSauceInterval;
    secretSauceActive = false;
    secretSauceCountdown = 30;
    document.getElementById('warning').style.display = 'none';
    document.getElementById('nightMode').style.display = 'none';
    winner = null;
    paused = false;
    updateStatus('Collect fish. First to ' + CONFIG.targetScore + '!');
    document.getElementById('powerups').innerHTML = '';
    updateChaosTimer();
  }

  function updateStatus(s){ document.getElementById('status').textContent = s; }
  function updateScoreUI(){
    const el = document.getElementById('scores');
    el.innerHTML = '';
    players.forEach(p=>{
      const span = document.createElement('span');
      span.className = `pchip ${p.chip}`;
      span.textContent = `${p.emoji} ${p.name}: ${p.score}`;
      el.appendChild(span);
    });
    document.getElementById('targetPts').textContent = CONFIG.targetScore;
  }
  
  function updatePowerUpsUI() {
    const el = document.getElementById('powerups');
    el.innerHTML = '';
    
    players.forEach(p => {
      p.activePowerUps.forEach(pu => {
        if (!pu.displayElement) {
          const div = document.createElement('div');
          div.className = 'powerup';
          div.innerHTML = `
            <span class="powerup-icon" style="color:${pu.type.color}">${pu.type.emoji}</span>
            <span>${pu.type.name}: ${p.name}</span>
            <span id="pu-timer-${pu.id}">${Math.ceil((pu.endTime - performance.now())/1000)}s</span>
          `;
          pu.displayElement = div;
          el.appendChild(div);
        } else {
          const timer = document.getElementById(`pu-timer-${pu.id}`);
          if (timer) {
            timer.textContent = `${Math.ceil((pu.endTime - performance.now())/1000)}s`;
          }
        }
      });
    });
  }
  
  function updateChaosTimer() {
    document.getElementById('timer').textContent = `Chaos in: ${secretSauceCountdown}s`;
  }

  let paused = false;
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase()==='p'){ paused = !paused; updateStatus(paused?'Paused':''); }
    if (e.key.toLowerCase()==='r'){ resetGame(); }
  });
  document.getElementById('startBtn').addEventListener('click', start);

  let winner = null;

  function handleInput(p){
    // Skip input handling if player is being eaten
    if (p.beingEaten) return;
    
    // Skip if not local player (player 0)
    if (p.id !== 0) return;
    
    const now = performance.now();
    let up = keys.has(p.controls.up) || keys.has(p.controls.up.toUpperCase());
    let down = keys.has(p.controls.down) || keys.has(p.controls.down.toUpperCase());
    let left = keys.has(p.controls.left) || keys.has(p.controls.left.toUpperCase());
    let right = keys.has(p.controls.right) || keys.has(p.controls.right.toUpperCase());

    // Inverted controls if laser-distracted
    if (now < p.invertUntil){ [up,down,left,right] = [down,up,right,left]; }

    const speed = CONFIG.playerSpeed * p.speedBoost;
    if (up) p.vy -= speed*0.6;
    if (down) p.vy += speed*0.6;
    if (left) p.vx -= speed*0.6;
    if (right) p.vx += speed*0.6;

    // Meow knockback
    if (keys.has(p.controls.meow) && now - p.lastMeow > CONFIG.meowCooldownMs){
      p.lastMeow = now;
      
      const range = p.superMeow ? CONFIG.meowKnockRange * 1.5 : CONFIG.meowKnockRange;
      const force = p.superMeow ? CONFIG.meowKnockForce * 1.5 : CONFIG.meowKnockForce;
      
      // Send meow action to server
      if (socket && socket.connected && isMultiplayerGame) {
        socket.emit('player-action', {
          action: 'meow',
          position: { x: p.x, y: p.y },
          superMeow: p.superMeow
        });
      }
      
      meowBursts.push({ 
        x: p.x, 
        y: p.y, 
        r: 10, 
        maxR: range, 
        born: now, 
        life: p.superMeow ? 420 : 320, 
        owner: p, 
        superMeow: p.superMeow 
      });
      
      // Create visual particles for meow effect
      createMeowParticles(p.x, p.y, p.color, p.superMeow ? CONFIG.meowParticles * 2 : CONFIG.meowParticles);
      
      // Apply effect immediately to others within range
      for (const other of players){
        if (other === p) continue;
        if (other.hasShield) continue; // Shield blocks meow
        if (other.beingEaten) continue; // Can't meow a player being eaten
        
        const dx = other.x - p.x, dy = other.y - p.y;
        const d = Math.hypot(dx,dy);
        if (d > 0 && d <= range){
          const nx = dx/d, ny = dy/d;
          const adjustedForce = force * (1 - d/range + 0.2);
          other.vx += nx * adjustedForce;
          other.vy += ny * adjustedForce;
          
          // Mark player as being meowed for visual effects
          other.isBeingMeowed = true;
          other.meowEffectUntil = now + 800;
          
          // Create visual particles at impact point
          createMeowParticles(other.x, other.y, other.color);
        }
      }
      
      // Apply effect to remote players (in multiplayer mode)
      if (isMultiplayerGame) {
        for (const id in remotePlayers) {
          const remotePlayer = remotePlayers[id];
          if (remotePlayer.hasShield) continue; // Shield blocks meow
          
          const dx = remotePlayer.x - p.x, dy = remotePlayer.y - p.y;
          const d = Math.hypot(dx,dy);
          if (d > 0 && d <= range){
            // Visual effect only - server handles actual physics
            createMeowParticles(remotePlayer.x, remotePlayer.y, remotePlayer.color || '#ffffff');
          }
        }
      }
      
      // Super meow also affects objects - only in single player mode, server handles in multiplayer
      if (p.superMeow && !isMultiplayerGame) {
        // Push treats away
        for (const t of treats) {
          const dx = t.x - p.x, dy = t.y - p.y;
          const d = Math.hypot(dx,dy);
          if (d > 0 && d <= range) {
            const nx = dx/d, ny = dy/d;
            const adjustedForce = force * 0.3 * (1 - d/range + 0.2);
            t.vx = nx * adjustedForce;
            t.vy = ny * adjustedForce;
          }
        }
        
        // Push roombas away
        for (const r of roombas) {
          const dx = r.x - p.x, dy = r.y - p.y;
          const d = Math.hypot(dx,dy);
          if (d > 0 && d <= range) {
            const nx = dx/d, ny = dy/d;
            const adjustedForce = force * 0.4 * (1 - d/range + 0.2);
            r.vx += nx * adjustedForce;
            r.vy += ny * adjustedForce;
          }
        }
      }
      
      updateStatus(`${p.name} used ${p.superMeow ? 'SUPER ' : ''}MEOW POWER!`);
    }
  }

  function updatePlayer(p){
    const now = performance.now();
    
    // Handle respawning if eaten
    if (p.beingEaten && now > p.eatenUntil) {
      respawnPlayer(p);
    }
    
    // Skip other updates if being eaten
    if (p.beingEaten) return;
    
    // Update meow effect status
    if (p.isBeingMeowed && now > p.meowEffectUntil) {
      p.isBeingMeowed = false;
    }
    
    // Update power-up timers and remove expired ones
    for (let i = p.activePowerUps.length - 1; i >= 0; i--) {
      const pu = p.activePowerUps[i];
      if (now > pu.endTime) {
        // Remove power-up UI element
        if (pu.displayElement && pu.displayElement.parentNode) {
          pu.displayElement.parentNode.removeChild(pu.displayElement);
        }
        
        // Call cleanup function
        if (pu.cleanup) pu.cleanup();
        
        // Remove from active power-ups
        p.activePowerUps.splice(i, 1);
      }
    }
    
    p.vx *= CONFIG.friction;
    p.vy *= CONFIG.friction;
    p.x += p.vx;
    p.y += p.vy;
    edgeBounce(p, p.r);
    
    // Treat magnet power-up - only in single player, server handles in multiplayer
    if (p.treatMagnet && !isMultiplayerGame) {
      for (const t of treats) {
        const dx = p.x - t.x;
        const dy = p.y - t.y;
        const d = Math.hypot(dx, dy);
        if (d < 150) {
          const force = 0.8 * (1 - d/150);
          t.vx += (dx/d) * force;
          t.vy += (dy/d) * force;
        }
      }
    }
    
    // Send position updates to server
    if (socket && socket.connected && isMultiplayerGame && p.id === 0) { // Only for local player
      // Send every few frames to reduce network traffic
      if (Math.random() < 0.1) { // 10% chance each frame
        socket.emit('player-update', {
          position: { 
            x: p.x, 
            y: p.y,
            vx: p.vx,
            vy: p.vy
          }
        });
      }
    }
  }

  function updateTreats(){
    // Skip treat movement in multiplayer mode - server handles this
    if (!isMultiplayerGame) {
      // Update treat positions with velocity
      for (const t of treats) {
        if (t.vx !== 0 || t.vy !== 0) {
          t.x += t.vx;
          t.y += t.vy;
          t.vx *= 0.95;
          t.vy *= 0.95;
          
          // Stop very small movements
          if (Math.abs(t.vx) < 0.1) t.vx = 0;
          if (Math.abs(t.vy) < 0.1) t.vy = 0;
          
          // Keep treats in bounds
          if (t.x < CONFIG.boundsPadding) { t.x = CONFIG.boundsPadding; t.vx *= -0.5; }
          if (t.x > W - CONFIG.boundsPadding) { t.x = W - CONFIG.boundsPadding; t.vx *= -0.5; }
          if (t.y < CONFIG.boundsPadding + 40) { t.y = CONFIG.boundsPadding + 40; t.vy *= -0.5; }
          if (t.y > H - CONFIG.boundsPadding) { t.y = H - CONFIG.boundsPadding; t.vy *= -0.5; }
        }
      }
    }
    
    // Collect
    for (let i=treats.length-1;i>=0;i--){
      const t = treats[i];
      for (const p of players){
        // Skip players being eaten
        if (p.beingEaten) continue;
        
        if (circleCollide(p.x,p.y,p.r, t.x,t.y,t.r)){
          p.score++;
          updateScoreUI();
          
          // Send treat collection to server
          if (socket && socket.connected && isMultiplayerGame && p.id === 0) { // Only for local player
            socket.emit('player-action', {
              action: 'collect-treat',
              treatId: t.id,
              score: p.score
            });
          }
          
          treats.splice(i, 1);
          
          // Create particle effect when collecting treats
          createMeowParticles(t.x, t.y, "#5dffea");
          
          if (p.score >= CONFIG.targetScore && !winner){
            endGameWithWinner(p);
          }
          break;
        }
      }
    }
    
    // Respawn timer - skip in multiplayer
    if (!isMultiplayerGame) {
      const now = performance.now();
      if (now >= nextTreatAt){
        nextTreatAt = now + CONFIG.treatRespawnMs;
        if (treats.length < CONFIG.treatsOnField) spawnTreat();
      }
    }
  }
  
  function endGameWithWinner(p) {
    winner = p;
    paused = true;
    updateStatus(`üéâ ${p.emoji} ${p.name} WINS! Press R to restart.`);
    
    // Send game end to server
    if (socket && socket.connected && isMultiplayerGame && p.id === 0) {
      socket.emit('player-action', {
        action: 'game-end',
        winner: p.name
      });
    }
  }

  function updateRoombas(){
    // Skip in multiplayer mode - server handles this
    if (isMultiplayerGame) return;
    
    for (const r of roombas){
      r.x += r.vx; r.y += r.vy;
      if (r.x < 40 || r.x > W-40) r.vx *= -1;
      if (r.y < 70 || r.y > H-40) r.vy *= -1;
      // Push players slightly
      for (const p of players){
        // Skip players being eaten
        if (p.beingEaten) continue;
        
        if (circleCollide(p.x,p.y,p.r, r.x,r.y,r.r)){
          const dx = p.x - r.x, dy = p.y - r.y; const d = Math.hypot(dx,dy)||1;
          const nx = dx/d, ny = dy/d;
          p.vx += nx*1.8; p.vy += ny*1.8;
          
          // Small particles when hitting roomba
          if (Math.random() < 0.3) {
            createMeowParticles(p.x - (nx*p.r), p.y - (ny*p.r), "#aaaaaa");
          }
        }
      }
    }
  }

  function updateDoge(){
    // Skip in multiplayer mode - server handles this
    if (isMultiplayerGame) return;
    
    const now = performance.now();
    if (!doge && now >= nextDogeAt){ nextDogeAt = now + CONFIG.dogeEveryMs; spawnDoge(); }
    if (doge){
      // If doge is eating a player
      if (doge.eating) {
        const eatingDuration = now - doge.eatingStartTime;
        
        // When done eating, release player (they will respawn)
        if (eatingDuration >= CONFIG.dogeEatTimeMs) {
          doge.eating = null;
        }
      } 
      // If doge is not currently eating anyone, find a player to chase
      else {
        // Find closest player to chase
        let closestDist = Infinity;
        let closestPlayer = null;
        for (const p of players) {
          // Skip players already being eaten
          if (p.beingEaten) continue;
          
          const d = dist(doge, p);
          if (d < closestDist) {
            closestDist = d;
            closestPlayer = p;
          }
        }
        
        // Chase closest player
        if (closestPlayer) {
          const dx = closestPlayer.x - doge.x;
          const dy = closestPlayer.y - doge.y;
          const d = Math.hypot(dx, dy) || 1;
          doge.vx = (dx/d) * CONFIG.dogeSpeed;
          doge.vy = (dy/d) * CONFIG.dogeSpeed;
          
          // In secret sauce mode, doge moves faster
          if (secretSauceActive) {
            doge.vx *= 1.5;
            doge.vy *= 1.5;
          }
          
          // Check if doge catches a player to eat them
          for (const p of players) {
            // Skip players already being eaten
            if (p.beingEaten) continue;
            
            if (circleCollide(p.x, p.y, p.r, doge.x, doge.y, doge.r)) {
              // Start eating player
              doge.eating = p;
              doge.eatingStartTime = now;
              
              // Mark player as being eaten
              p.beingEaten = true;
              p.eatenUntil = now + CONFIG.dogeEatTimeMs;
              
              // Set respawn point (random position)
              p.respawnPoint = {
                x: rnd(100, W-100),
                y: rnd(100, H-100)
              };
              
              // Eating effect particles
              createExplosion(p.x, p.y, "#ff6600", 25);
              
              // Secret sauce: player loses treats when eaten
              if (secretSauceActive && p.score > 0) {
                const lostTreats = Math.min(p.score, 3);
                p.score -= lostTreats;
                updateScoreUI();
                
                // Spawn lost treats
                for (let i = 0; i < lostTreats; i++) {
                  const t = { 
                    id: Math.random().toString(36).substring(2, 15),
                    x: doge.x + rnd(-40, 40),
                    y: doge.y + rnd(-40, 40),
                    r: CONFIG.treatRadius, 
                    emoji:'üêü',
                    vx: rnd(-2, 2),
                    vy: rnd(-2, 2)
                  };
                  treats.push(t);
                }
              }
              
              updateStatus(`${p.name} was eaten by Doge!`);
              break;
            }
          }
        }
      }
      
      // Update doge position
      if (!doge.eating) {
        doge.x += doge.vx; doge.y += doge.vy;
      }
      
      doge.ttl -= 16;
      
      // Despawn if TTL expired
      if (doge.ttl <= 0 || doge.x < -80 || doge.x > W+80 || doge.y < -80 || doge.y > H+80) doge = null;
    }
  }

  function updateLasers(){
    // Skip in multiplayer mode - server handles this
    if (isMultiplayerGame) return;
    
    for (let i = 0; i < lasers.length; i++) {
      const laser = lasers[i];
      laser.t += 1;
      
      // Retarget sometimes (different timing for each laser)
      if (laser.t % 120 === 0){
        laser.targetX = rnd(40, W-40);
        laser.targetY = rnd(90, H-40);
      }
      
      const dx = laser.targetX - laser.x;
      const dy = laser.targetY - laser.y;
      const d = Math.hypot(dx,dy)||1;
      laser.x += (dx/d) * laser.speed;
      laser.y += (dy/d) * laser.speed;

      // Invert controls on touch
      for (const p of players){
        // Skip players being eaten
        if (p.beingEaten) continue;
        
        if (circleCollide(p.x,p.y,p.r, laser.x,laser.y, laser.r+6)){
          // Shield prevents laser distraction
          if (!p.hasShield) {
            p.invertUntil = performance.now() + CONFIG.laserInvertMs;
            updateStatus(`${p.name} is distracted by the LASER!`);
            
            // Particle effect when hit by laser
            createMeowParticles(laser.x, laser.y, "#ff3333");
          }
        }
      }
    }
  }

  function updateMeowBursts(){
    const now = performance.now();
    for (let i=meowBursts.length-1;i>=0;i--){
      const b = meowBursts[i];
      const life = (now - b.born);
      b.r = b.maxR * Math.min(1, life / b.life);
      if (life > b.life) meowBursts.splice(i,1);
    }
  }
  
  // Update particles
  function updateParticles() {
    for (let i = meowParticles.length - 1; i >= 0; i--) {
      const p = meowParticles[i];
      p.x += p.vx;
      p.vy += 0.1; // Gravity
      p.y += p.vy;
      p.vx *= 0.95; // Air resistance
      p.vy *= 0.95;
      p.life -= 1;
      p.opacity = p.life / 80;
      
      if (p.life <= 0) {
        meowParticles.splice(i, 1);
      }
    }
  }
  
  // Update tornado
  function updateTornado() {
    // Skip in multiplayer mode - server handles this
    if (isMultiplayerGame) return;
    
    if (!tornado) return;
    
    tornado.x += tornado.vx;
    tornado.y += tornado.vy;
    tornado.angle += tornado.rotationSpeed;
    
    // Bounce off edges
    if (tornado.x < tornado.r || tornado.x > W - tornado.r) tornado.vx *= -1;
    if (tornado.y < tornado.r || tornado.y > H - tornado.r) tornado.vy *= -1;
    
    // Pull players toward tornado
    for (const p of players) {
      // Skip players being eaten
      if (p.beingEaten) continue;
      
      const dx = tornado.x - p.x;
      const dy = tornado.y - p.y;
      const d = Math.hypot(dx, dy);
      
      if (d < tornado.r * 2) {
        const pullFactor = (1 - d / (tornado.r * 2)) * tornado.pullForce;
        p.vx += (dx/d) * pullFactor;
        p.vy += (dy/d) * pullFactor;
        
        // Spin effect
        const angle = Math.atan2(dy, dx);
        const perpX = -Math.sin(angle);
        const perpY = Math.cos(angle);
        p.vx += perpX * pullFactor * 0.8;
        p.vy += perpY * pullFactor * 0.8;
        
        // Create particles
        if (Math.random() < 0.1) {
          createMeowParticles(p.x, p.y, "#bbbbbb");
        }
      }
    }
    
    // Update tornado particles
    for (const p of tornado.particles) {
      p.angle += p.speed;
      p.x = tornado.x + Math.cos(p.angle) * p.distance;
      p.y = tornado.y + Math.sin(p.angle) * p.distance;
    }
    
    // Move treats caught in tornado
    for (const t of treats) {
      const dx = tornado.x - t.x;
      const dy = tornado.y - t.y;
      const d = Math.hypot(dx, dy);
      
      if (d < tornado.r * 2) {
        const pullFactor = (1 - d / (tornado.r * 2)) * tornado.pullForce * 0.8;
        t.vx += (dx/d) * pullFactor;
        t.vy += (dy/d) * pullFactor;
        
        // Spin effect
        const angle = Math.atan2(dy, dx);
        const perpX = -Math.sin(angle);
        const perpY = Math.cos(angle);
        t.vx += perpX * pullFactor * 0.8;
        t.vy += perpY * pullFactor * 0.8;
      }
    }
  }
  
  function updatePowerUps() {
    // Skip power-up spawning in multiplayer mode - server handles this
    const now = performance.now();
    
    // Check for power-up collisions
    for (let i = powerUps.length - 1; i >= 0; i--) {
      const p = powerUps[i];
      p.pulsePhase = (p.pulsePhase + 0.05) % (Math.PI * 2);
      
      // Check if any player collected this power-up
      for (const player of players) {
        // Skip players being eaten
        if (player.beingEaten) continue;
        
        if (circleCollide(player.x, player.y, player.r, p.x, p.y, p.r)) {
          // Mark as collected
          p.collectTime = now;
          p.collectPlayer = player;
          
          // Apply power-up effect
          const endTime = now + p.type.duration;
          const puId = now.toString() + Math.random().toString().slice(2, 6);
          
          // Call the power-up effect function and get the cleanup function
          const cleanup = p.type.effect(player);
          
          // Store active power-up
          player.activePowerUps.push({
            id: puId,
            type: p.type,
            endTime: endTime,
            cleanup: cleanup,
            displayElement: null
          });
          
          // Create particle effect
          createExplosion(p.x, p.y, p.type.color);
          
          // Remove power-up from array
          powerUps.splice(i, 1);
          
          updateStatus(`${player.name} got ${p.type.name}!`);
          
          // Send powerup collection to server (for player 0 only - local player)
          if (socket && socket.connected && isMultiplayerGame && player.id === 0) {
            socket.emit('player-action', {
              action: 'powerup',
              powerUpId: p.id,
              type: p.type.name
            });
          }
          
          break;
        }
      }
    }
    
    // Chance to spawn a new power-up - only in single player
    if (!isMultiplayerGame && Math.random() < CONFIG.powerUpChance && powerUps.length < 3) {
      spawnPowerUp();
    }
  }
  
  function updateWeather() {
    // Skip in multiplayer mode - server handles this
    if (isMultiplayerGame) return;
    
    const now = performance.now();
    
    // End current weather event if time's up
    if (currentWeather && now >= currentWeather.endTime) {
      currentWeather.event.onEnd();
      currentWeather = null;
    }
    
    // Start new weather event if it's time
    if (CONFIG.weatherEvents && !currentWeather && now >= nextWeatherEvent) {
      const randomEvent = WEATHER_EVENTS[Math.floor(Math.random() * WEATHER_EVENTS.length)];
      currentWeather = {
        event: randomEvent,
        endTime: now + CONFIG.weatherDuration
      };
      randomEvent.onStart();
      nextWeatherEvent = now + CONFIG.weatherDuration + CONFIG.weatherCooldown;
    }
  }
  
  function updateSecretSauce() {
    // Skip in multiplayer mode - server handles this
    if (isMultiplayerGame) return;
    
    const now = performance.now();
    
    // Update countdown timer
    if (!secretSauceActive) {
      const secondsLeft = Math.ceil((nextSecretSauce - now) / 1000);
      if (secretSauceCountdown !== secondsLeft) {
        secretSauceCountdown = secondsLeft;
        updateChaosTimer();
      }
    }
    
    // End secret sauce mode
    if (secretSauceActive && now >= nextSecretSauce + CONFIG.secretSauceDuration) {
      secretSauceActive = false;
      document.getElementById('warning').style.display = 'none';
      updateStatus('');
      
      // Schedule next chaos mode
      nextSecretSauce = now + CONFIG.secretSauceInterval;
    }
    
    // Start secret sauce mode
    if (!secretSauceActive && now >= nextSecretSauce) {
      secretSauceActive = true;
      document.getElementById('warning').style.display = 'block';
      updateStatus('‚ö†Ô∏è CHAOS MODE ACTIVATED! ‚ö†Ô∏è');
      document.getElementById('timer').textContent = 'CHAOS MODE!';
      
      // Spawn additional chaos
      for (let i = 0; i < 3; i++) spawnPowerUp();
      if (Math.random() < 0.5) spawnDoge();
      for (let i = 0; i < 3; i++) spawnTreat();
    }
  }

  function loop(t){
    requestAnimationFrame(loop);
    const now = t;
    if (!running) return;
    let delta = now - last;
    last = now;
    if (delta > 100) delta = 100; // clamp
    acc += delta;

    // Update UI elements that don't depend on physics tick
    updatePowerUpsUI();
    updateCatImagePositions();
    
    // Update remote player positions with interpolation
    updateRemotePlayerPositions();
    
    // DEBUGGING: Update debug info occasionally
    if (CONFIG.debugMode && Math.random() < 0.05) updateDebugInfo();
    
    // In multiplayer, perform game element interpolation
    if (isMultiplayerGame) {
      updateInterpolation();
    }

    while (acc >= dt){
      if (!paused && !winner){
        for (const p of players){ handleInput(p); updatePlayer(p); }
        updateTreats();
        
        // Only run these updates in single player or if specifically allowed in multiplayer
        if (!isMultiplayerGame) {
          updateRoombas();
          updateDoge();
          updateLasers();
          updateTornado();
          updateWeather();
          updateSecretSauce();
        }
        
        // These always run regardless of game mode
        updateMeowBursts();
        updateParticles();
        updatePowerUps();
      }
      acc -= dt;
    }
    render();
  }

  // ======== RENDER ========
  function renderBG(){
    // Gradient-ish grid
    ctx.fillStyle = '#10131a';
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.globalAlpha = 0.12;
    for (let x=0; x<W; x+=40){
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x, 0, 1, H);
    }
    for (let y=0; y<H; y+=40){
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, y, W, 1);
    }
    ctx.restore();

    // Top safe HUD strip
    ctx.fillStyle = 'rgba(0,0,0,.25)';
    ctx.fillRect(0,0,W,50);
  }

  function drawCircle(x,y,r, fill, stroke){
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    if (fill){ ctx.fillStyle = fill; ctx.fill(); }
    if (stroke){ ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke(); }
  }

  function render(){
    renderBG();

    // Treats
    for (const t of treats){
      drawCircle(t.x,t.y,t.r+4,'#1b2a2a',null);
      ctx.font = '18px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('üêü', t.x, t.y);
    }

    // Tornado
    if (tornado) {
      // Draw tornado particles
      for (const p of tornado.particles) {
        ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw tornado center
      ctx.font = '32px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('üå™Ô∏è', tornado.x, tornado.y);
    }
    
    // PowerUps
    for (const p of powerUps) {
      // Pulse effect
      const pulseSize = Math.sin(p.pulsePhase) * 4;
      
      // Glow effect
      ctx.save();
      const gradient = ctx.createRadialGradient(p.x, p.y, p.r-5, p.x, p.y, p.r+10+pulseSize);
      gradient.addColorStop(0, p.type.color + '60');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r+10+pulseSize, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // Power-up circle
      drawCircle(p.x, p.y, p.r+pulseSize, '#2b2f3a', p.type.color);
      
      // Power-up emoji
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.emoji, p.x, p.y);
    }

    // Roombas
    for (const r of roombas){
      drawCircle(r.x,r.y,r.r,'#2b2f3a','#3a4152');
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(r.emoji, r.x, r.y);
    }

    // Doge
    if (doge){
      // Special effect for secret sauce mode
      if (secretSauceActive) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        drawCircle(doge.x, doge.y, doge.r+8, '#ff5500', null);
        ctx.restore();
      }
      
      // Draw doge differently if eating a player
      if (doge.eating) {
        // Larger mouth effect
        drawCircle(doge.x, doge.y, doge.r + 5, '#3a2f2b', '#5a423a');
        
        // Blood effect
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(doge.x, doge.y, doge.r - 5, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        
        ctx.font = '25px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üê∫', doge.x, doge.y); // Use wolf emoji for eating doge
      } else {
        drawCircle(doge.x, doge.y, doge.r, '#3a2f2b', '#5a423a');
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üê∂', doge.x, doge.y);
      }
    }

    // Lasers
    for (const laser of lasers) {
      drawCircle(laser.x, laser.y, laser.r, '#e53935', '#ffffff');
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('üî¥', laser.x, laser.y);
    }

    // Meow bursts
    for (const b of meowBursts){
      ctx.save();
      const gradient = ctx.createRadialGradient(b.x, b.y, 1, b.x, b.y, b.r);
      if (b.superMeow) {
        gradient.addColorStop(0, b.owner ? b.owner.color + '60' : '#ffffff60');
        gradient.addColorStop(0.6, b.owner ? b.owner.color + '20' : '#ffffff20');
        gradient.addColorStop(1, 'transparent');
      } else {
        gradient.addColorStop(0, b.owner ? b.owner.color + '40' : '#ffffff40');
        gradient.addColorStop(1, 'transparent');
      }
      ctx.fillStyle = gradient;
      ctx.globalAlpha = b.superMeow ? 0.4 : 0.3;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.globalAlpha = 0.18;
      drawCircle(b.x, b.y, b.r, null, '#ffffff');
      ctx.restore();
    }
    
    // Particles
    for (const p of meowParticles) {
      ctx.save();
      ctx.globalAlpha = p.opacity;
      drawCircle(p.x, p.y, p.r, p.color, null);
      ctx.restore();
    }

    // Winner banner
    if (winner){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 42px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`üéâ ${winner.emoji} ${winner.name} WINS!`, W/2, H/2 - 30);
      ctx.font = 'bold 36px system-ui';
      ctx.fillText(`Winner Winner Fish Dinner!`, W/2, H/2 + 20);
      ctx.font = '18px system-ui';
      ctx.fillText('Press R to restart', W/2, H/2 + 60);
      ctx.restore();
    }
  }

  // ======== BOOT ========
  // Preload all cat GIF images
  function preloadCatImages() {
    CAT_GIFS.forEach(url => {
      const img = new Image();
      img.src = url;
    });
  }
  
  // Start preloading images
  preloadCatImages();
  
  // Initialize multiplayer when page loads
  document.addEventListener('DOMContentLoaded', initializeMultiplayer);
  
  // Show start screen, wait for Enter/click
  // (Game starts via start())
})();
</script>
</body>
</html>
